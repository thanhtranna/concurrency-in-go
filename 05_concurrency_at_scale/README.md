## 5章 大規模開発での並行処理

### 5.1 エラー伝播

- Goではコールスタックのフレームごとのエラー処理を矯正することでエラーが黙認されることを防ごうとした
- エラーが持ち回すべきこと
  - 何が起きたのか
  - いつどこでエラーが発生したか
  - ユーザー向けの読みやすいメッセージ
  - ユーザーがさらに情報を得るためにはどうするべきか
- 二つのエラー
  - バグ
  - 既知のエッジケース
- モジュールの境界で元のエラーを自分たちのモジュールのエラー型に書き換える
- ユーザーへのメッセージ内にログIDを含めて参照できるようにするべき

### 5.2 タイムアウトとキャンセル処理
-  並行処理のプロセスにタイムアウトをサポートしてもらいたいパターン
  - システム飽和状態
  - 新鮮でないデータ
  - デッドロックを防ぐ仕組み
  - セクションのまとめ
- 並行処理のプロセスがキャンセルされるパターン
  - タイムアウト
  - ユーザーによる介入
  - 親のキャンセル
  - 複製されたリクエスト
- 並行処理のプロセスをキャンセルする方法
  - doneチャンネル
  - context.Context
- 複製されたメッセージを送らないようにする方法
  - 最初か最後に報告された結果だけを受け入れる
  - 親のゴルーチンに対しポーリングして結果を得る

### 5.3 ハートビート
- 並行処理のプロセスが生きていることを外に伝える
- 二つのハートビート
  - 一定周期で発生するハートビート
  - 仕事単位で発生するハートビート

### 5.4 複製されたリクエスト
- リクエストを複数のハンドラーに対して複製して、早く返ってきた結果を使用する
- すべてのハンドラーがリクエストに対して等しく処理できる機会を与えられるべき
- ハンドラーが処理のために使うリソースはどんなものであろうとどうように複製する必要がある

### 5.5 流量制限
- 流量制限≒ある種のリソースへのアクセス回数を一定時間の間に有限の回数に制限すること
- リソースの例
  - APIへの接続
  - ディスクへの読み書き
  - ネットワークパケット
  - エラー
- なぜ流量制限をかけるか
  - 攻撃を防げる
  - ユーザーに対してどの程度の性能を安定して供給できるか保証する
  - システムの性能と安定性を推測できるようにする
- トークンバケット
- トークンが補充される速度(r)、バケットの深さ(b)
- rateパッケージ
  - Limit型
  - NewLimiter関数

### 5.6 不健全なゴルーチンを直す
- ゴルーチンは自力で復活できない不健全な状態になってしまうことがある
- ゴルーチンが健康な状態であることを維持し、不健全な状態になったら再起動することを「回復」という
- 「steward」≒ゴルーチンの健全性を監視するロジック
- 「ward」≒stewardが監視するゴルーチン

### 5.7 まとめ
