## 1章 並行処理入門

### 1.1 ムーアの法則、Webスケール、そして私たちのいる混沌

- ムーアの法則
  - 集積回路内のコンポーネントの数は2年で2倍になる
- アムダールの法則
  - そのプログラムの何割を並列化出来ないかによって、並列化による性能向上の上限が決まる
- The free lunch is over
  - 開発者自身が並列化について考える必要がある

### 1.2 なぜ並行処理が難しいのか

#### 1.2.1 競合状態

- 競合状態は、2つ以上の操作が正しい順序で実行されなければいけないところで、プログラムが順序を保証するように書かれていない場合に発生
- Sleepを使っても論理的に正しい解決策ではない
- 常に論理的正当性を目指すべき

#### 1.2.2 アトミック性

- アトミック性≒それが操作されている特定の「コンテキスト」の中では分割不能、中断不可
- アトミック性は、注目するスコープによって変わりうる
  - 処理
  - OS
  - マシン
  - アプリケーション
- i++
  - iの値を取得する
  - iの値を1増やす
  - iの値を保存する
- 大抵の式はアトミックではない

#### 1.2.3 メモリアクセス同期

- クリティカルセクション≒リソースに対する排他的なアクセスが必要な場所
- 同期的メモリアクセスは、保守性や性能の問題がある

#### 1.2.4 デッドロック、ライブロック、リソース枯渇

- デッドロック≒すべての並行なプロセスがお互いの処理を待ち合っている状態
- Coffman条件
  - 相互排他
  - 条件待ち
  - 横取り不可
  - 循環待ち
- ライブロック≒並行処理を行っているが、その操作をプログラムの状態を全く進めていない
- リソース枯渇≒並行プロセスが必要なリソースを取得できない状況

#### 1.2.5 並行処理の安全性を見極める

- チーム規模で行うプロジェクトで並行処理のコードを書くことの難しさ

### 1.3 複雑さを前にした簡潔さ

- Go1.8でのガベージコレクションの停止時間は10~100マイクロ秒
- Goのランタイムは並行処理の操作をOSスレッドにマルチプレキシングする
