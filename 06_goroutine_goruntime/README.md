## 6章 ゴルーチンとGoランタイム

### 6.1 ワークスティーリング
- GoはゴルーチンをOSスレッドにマルチプレキシングするアルゴリズムにワークスティーリングを採用
- 多くのプロセッサーではフェアスケジューリングを採用
- フェアスケジューリングアルゴリズム
　- 各プロセッサに均等にタスクを分配する
- ワークスティーリングアルゴリズム
  - 分岐地点で、タスクをスレッドに紐づくデックの最後尾に追加する
  - スレッドがアイドルなときは、他のスレッドに紐付いたデックの先頭からタスクを盗む
  - 未達の合流地点では、スレッドが持っているデックの最後尾からタスクを取り出す
  - スレッドがデックが空の場合は、合流地点で停止するか、他のスレッドに紐付いたデックの先頭からタスクを盗む
- 最後尾のタスクはほぼ親の合流を完了させるために必要になる
- 最後尾のタスクはほぼプロセッサのキャッシュにある

#### 6.1.1 タスクと継続、どちらを盗むのか
- fork-joinのパラダイムにおける二つの選択
  - タスク
  - 継続
- Goのワークスティーリングアルゴリズムがデックに入れたり盗んだりするのは継続
- 継続スティーリングにはコンパイラのサポートが必要
- コンパイラのサポートがない言語では、チャイルドスティーリングを実装している
- Goのスケジューラの3つの概念
  - G : ゴルーチン
  - M : OSスレッド
  - P : コンテキスト
- Goのランタイムでは、Mが起動されてPを管理し、PがGをスケジューリングする

### 6.2 すべての開発者にこの言葉を贈ります
- ゴルーチンを扱うために必要なのは`go`キーワードだけ
- スケーラブル、効率的、単純

### 6.3 結論
