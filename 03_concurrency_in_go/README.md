## 3章 Goにおける並行処理の構成要素

### 3.1 ゴルーチン（goroutine）

- ゴルーチンとは他のコードに対して並行に実行している関数のこと
- ゴルーチンはOSスレッドではなく、グリーンスレッドでもない
- ゴルーチンはコルーチンという高水準の抽象化
- コルーチンは複数のポイントをもつ、割り込みされることのないサブルーチン
- GoはM:Nスケジューラでゴルーチンをホストする
- Goはfork-joinモデルという並行処理のモデルに従う
- クロージャは作成されたスコープを閉じ込めて変数を取り込む
- ゴルーチンはそれが作られたアドレス空間と同じ空間で実行する
- 生成されたゴルーチンのには数キロバイトのメモリが割り当てられる
- ゴルーチンの生成コストは非常に低い
  - 8GBのRAMで何百万ものゴルーチンを起動できる
  - コンテキストスイッチには0.255マイクロ秒

### 3.2 syncパッケージ

- Goはメモリアクセス同期のプリミティブの上に新しい並行処理プリミティブを作った
- structのような非常に小さいスコープに対して使用する

3.2.1 WaitGroup

- WaitGroup
- wg.Add()
- wg.Done()
- Addの呼び出しは監視対象のゴルーチンの直前に書く

3.2.2 MutexとRWMutex

- mutex≒mutual exclusion
- チャネルは通信によってメモリを共有し、Mutexは開発者が同期アクセスの慣習を作る
- sync.Mutex
- defer lock.Unlock()
- sync.RWMutex

3.2.3 Cond

- Cond≒ゴルーチンが待機したりイベントの発生を知らせるためのランデブーポイント
- イベント≒2つ以上のゴルーチンでそれが発生したということ以外の情報がない任意のシグナル
- Cond型はチャネルを使うよりも性能が高い

3.2.4 Once

- Once≒Doに渡された関数が一度しか実行されないようにする
- Doに渡された一意な関数を数えるわけではなく、Doが呼び出された回数を数える

3.2.5 Pool

- Pool≒オブジェクトプールパターンを並行処理で安全な形で実装したもの
- コストが高いもの（e.g. DB接続）を作るときに数を制限するために使用する
- オブジェクト生成を前倒ししてそれを再利用することで、無駄なアロケーションを防ぐ

### 3.3 チャネル（channel）

- チャネルを使うときはchan型の変数に値を渡し、その値をチャネルから読み込む
- プログラムはチャネルが存在するメモリ中の同じ場所の値を参照する
- チャネルは一方向だけにデータが流れるようにも宣言可能
  - <-chan
  - chan<-
- <-演算子からの受信は2つの値を返すことも可能
- 閉じたチャネルからも読み込むことが可能
- チャネルを閉じることは複数のゴルーチンに同時にシグナルを送信する方法の一つ
- バッファ付きチャネル
- バッファなしチャネル
- プログラム内では出来る限りチャネルの所有権のスコープを小さくするべき

### 3.4 select文

- 目的は、チャネルをまとめて抽象化すること
- 構文はswitch文と同じ
- 処理は各ケースのチャネルの読み（書き）込み順
- どのチャネルも準備できていないときはselect全体がブロックする
- 同時に読み（書き）込まれた場合は、乱数によってどれかのケースが読まれる
- caseに対してtime処理をかけることでタイムアウトなどの処理も可能

### 3.5 GOMAXPROCSレバー

- GOMAXPROCS = Goプログラムで利用するOSスレッド数の上限
- マシンの全CPUコアを活用したいため、デフォルトではコア数が設定されている

### 3.6 まとめ

- sync/atomic
  - AddT
  - CompareAndSwapT
  - LoadT
  - StoreT
  - SwapT
- atomic.Value
  - Load
  - Store
